---
alwaysApply: true
---
# Lien Project Rules

## What is Lien?
Local-first semantic code search tool providing context to AI coding assistants via MCP (Model Context Protocol).

**Key Facts:**
- Package: `@liendev/lien`
- Port: 7133 (L=7, I=1, E=3, N=3)
- License: MIT | Domain: lien.dev

**Structure:**
```
packages/cli/src/
├── cli/         # Commands (init, index, serve, status)
├── mcp/         # MCP server
├── indexer/     # Chunking, scanning, test associations
├── embeddings/  # Local embeddings (transformers.js)
├── vectordb/    # LanceDB vector storage
├── config/      # Config management & migration
├── frameworks/  # Framework detection (Node.js, Laravel)
└── git/         # Git integration
```

---

## Documentation Organization

### Temporary Documentation Rule

**ALL temporary documents MUST go in `.wip/` folder (gitignored).**

Examples of temporary docs:
- Dogfooding analysis and evaluations
- Implementation plans and status reports
- Code quality reviews and verification reports
- Performance benchmarks and test results
- Brainstorming and design exploration
- Session notes and continuation plans

**When AI assistant creates temporary documentation:**
1. Always create in `.wip/` folder
2. Use descriptive names with dates: `dogfooding-analysis-2025-11-19.md`
3. Never create temporary docs in project root
4. Extract key findings to permanent docs before session ends

### Permanent Documentation

These live in project root and are tracked in git:
- `README.md` - Main project documentation
- `CHANGELOG.md` - Release history (maintained by release script)
- `CONTRIBUTING.md` - Contributor guidelines
- `docs/` - Architecture and design documentation

**Rule:** If it's temporary or experimental → `.wip/`. If it's permanent → root or `docs/`.

---

## Core Principles

### KISS (Keep It Simple, Stupid)
- Simple > Clever
- Code junior devs can understand
- Question complexity: "Can this be simpler?"

### YAGNI (You Aren't Gonna Need It)
- Don't build "just in case"
- Wait for actual need
- Delete unused code aggressively

### DRY (Don't Repeat Yourself)
- But don't abstract too early (wait for 3rd use)
- Duplication > wrong abstraction

### Single Responsibility
- Each function does ONE thing
- If you can't explain it in one sentence, split it

### Fail Fast
- Validate inputs early
- Throw errors immediately
- Use TypeScript types to catch errors at compile time

---

## Data Transformation with collect.js

Use `collect.js` for readable data transformations instead of imperative loops.

### When to Use
- Aggregating data (groupBy, countBy, sum)
- Chaining multiple transformations (map → filter → sort)
- Building lookup structures from arrays

### When NOT to Use
- Simple single operations (use native `.map()`, `.filter()`)
- Performance-critical hot paths
- When it adds complexity rather than reducing it

### Patterns
```typescript
import collect from 'collect.js';

// ✅ Good: Multiple transformations, aggregation
const byMetric = collect(violations)
  .groupBy('metricType')
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  .map((group: any) => group.sum('delta'))
  .all() as unknown as Record<string, number>;

// ✅ Good: Flattening nested structures
const allItems = collect(Object.values(data))
  .flatMap(d => d.items)
  .sortByDesc('score')
  .all() as Item[];

// ❌ Avoid: Simple operations (use native)
const names = items.map(i => i.name);  // Not: collect(items).pluck('name').all()
```

### TypeScript Note
collect.js has limited type inference. Use `as unknown as T` for complex chains and add explanatory comments.

---

## Critical Rules

### Naming Conventions
- **Variables/Functions:** camelCase (`indexFile`, `vectorDB`)
- **Classes/Interfaces:** PascalCase (`VectorDB`, `CodeChunk`)
- **Constants:** UPPER_SNAKE_CASE (`DEFAULT_PORT`)
- **Files:** kebab-case (`vector-db.ts`)

### Import Order
```typescript
// 1. Node built-ins
import fs from 'fs/promises';
// 2. External dependencies
import { Command } from 'commander';
// 3. Internal modules
import { VectorDB } from '../vectordb/lancedb.js';
```

### Commits
Follow Conventional Commits:
- `feat(scope): description` - New feature
- `fix(scope): description` - Bug fix
- `docs(scope): description` - Documentation
- `refactor(scope): description` - Code refactor
- `perf(scope): description` - Performance
- `test(scope): description` - Tests
- `chore(scope): description` - Maintenance

**NEVER use `git commit --amend`** - Always create new commits. If a commit needs fixing, create a follow-up commit instead.

---

## Before EVERY Commit (MANDATORY)

```bash
npm run typecheck  # Must pass with 0 errors
npm run build      # Must compile successfully
npm test           # All tests must pass
```

**No exceptions.** This prevents broken builds.

---

## Feature Decision Framework

Before adding features, ask:
1. Is this needed for MVP? (No → defer)
2. Can users work around this? (Yes → defer)
3. Is this critical for core value? (No → defer)

**Bias toward simplicity.** Defer everything that isn't absolutely necessary.

---

## CURSOR_RULES_TEMPLATE.md Maintenance

**Single Source:** `/packages/cli/CURSOR_RULES_TEMPLATE.md`

Gets bundled with npm and copied to user projects via `lien init`.

**For Lien Development (Dogfooding):**
```bash
# After editing packages/cli/CURSOR_RULES_TEMPLATE.md, regenerate:
cp packages/cli/CURSOR_RULES_TEMPLATE.md .cursor/rules/lien.mdc
```

- ✅ `.cursor/rules/lien.mdc` - Generated (gitignored)
- ✅ `.cursor/rules/project.mdc` - Project rules (tracked)
- ✅ `packages/cli/CURSOR_RULES_TEMPLATE.md` - Source (tracked)

---

## Common Commands

```bash
# Development
npm run dev              # Watch mode
npm run typecheck        # Type check only
npm test                 # Run tests
npm run build            # Build CLI

# Release (in root)
npm run release -- patch "fix: description"
npm run release -- minor "feat: description"
npm run release -- major "BREAKING: description"
```

---

## When in Doubt

1. **Prefer readability over cleverness**
2. **Make it work, then make it good, then (maybe) make it fast**
3. **Delete code rather than comment it out**
4. **Ask: "Will I understand this in 6 months?"**
5. **Test on real codebases early and often**

---

**Ship early, ship often.** Perfect is the enemy of done.

*"Any fool can write code that a computer can understand. Good programmers write code that humans can understand."* - Martin Fowler
